# How I setup the project

## Frontend

### NextJS
*This content is copy/learn from the Ebook: React Application Architecture for Production by Adam Giese*

```sh
npx create-next-app@latest uz-app --typescript
```

There are a couple of things that are specific to Next.js. Let’s look at the following file and folder structure of a simple Next.js application:

```
- .next
- public
- src
  - pages
    - _app.tsx
    - index.tsx
- next.config.js
- package.json
```

Let’s analyze each file and folder one by one:

- `.next`: Contains production-ready files generated by running the build command of Next.js.

- `public`: Contains all static assets of the application.
`src/pages`: This is a special folder in Next.js where all pages defined here become available at corresponding routes. This is possible thanks to the filesystem-based routing system. The pages folder can also live in the root of the project, but it is nice to keep everything in the src folder.

- `src/pages/_app.tsx`: The _app.tsx file is a special file that exports a React component that wraps every page when rendered. By wrapping pages with this special component, we can add custom behavior for our application, such as adding any global configurations, providers, styles, layouts, and more to all the pages.

- `src/pages/index.tsx`: This is how we declare pages of the application. This shows how the root page is defined. 

- `next.config.js`: This is where we can extend the default functionalities such as Webpack configuration and other things in a simple way.

- `package.json`: Every Next.js application includes the following npm scripts:
    - `dev`: Starts a development server on localhost:3000
    - `build`: Builds the application for production
    - `start`: Starts the production build on localhost:3000

### TypeScript

Our project already has TypeScript configured. The TypeScript configuration is defined in the tsconfig.json file at the root of the project. It allows us to configure how strict we want it to be based on our needs:


```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "src"],
  "exclude": ["node_modules"]
}
```
We will not dive too deeply into every configuration property since most of the properties have been auto-generated. However, there is one thing that was also provided:

```js
"baseUrl": ".",
"paths": {
    "@/*": ["./src/*"]
}
```
This will tell the TypeScript compiler that anything imported via @/* will refer to the src folder.

Previously, we had to perform messy imports, like so:

```js
import { Component } from '../../../components/component'
```

Now, we can import components like so:


```js
import { Component } from '@/components/component'
```
No matter how many nested levels we have, we can always import with absolute paths, and we will not be required to change our import statement should we decide to move the consumer file somewhere else.

### ESLint
Linting is a process where linters analyze source code and detect any potential issues in the code base.

We will be using ESLint, which is the most popular linting tool for JavaScript. It can be configured with different plugins and rules to adapt the linter to our application’s needs.

The ESLint configuration is defined in the `.eslintrc.js` file at the root of the project. We can add different rules, extend them with different plugins, and override which files to apply the rules to so that they suit our application’s needs.

Sometimes, we don’t want to lint every folder and file, so we can tell ESLint to ignore folders and files by defining them in the `.eslintignore` file.

ESLint has great integration with editors and IDEs so that we can see any potential issues in the file while we are coding.

To run our linter, we have defined the linting script in `package.json`:


```json
"lint": "eslint --ext .ts,.tsx ./src",
```

By running npm run lint, we will lint every .ts and .tsx file in the src directory, and the linter will notify us about any potential issues.

### Prettier
Prettier is a great tool for formatting code. It enforces a consistent coding style across the entire code base. By utilizing the “format on save” feature in our IDE, we can automatically format the code based on the configuration provided in the .prettierrc file. It will also give us good feedback when something is wrong with the code. If it doesn’t auto-format, something is wrong with the code and it needs to be fixed.

Prettier comes with a default configuration out of the box. We can override this by creating the `.prettierrc` file and modifying the configuration.

Just as with ESLint, sometimes, there are files we do not want to auto-format. We can tell Prettier to ignore files and folders by adding them to the `.prettierignore` file.

To run Prettier, we have defined a couple of scripts in `package.json`:


```json
"prettier": "prettier \"**/*.+(json|ts|tsx)\"",
"format:check": "npm run prettier -- --check",
"format:fix": "npm run prettier -- --write",
```

As we can see, we can run `npm run format:check` to just check the formatting without trying to fix it. If we want to fix it, then we can run `npm run format:fix`, which will modify the files that need to be fixed.

### Pre-commiting
Having static code analysis tools such as TypeScript, ESLint, and Prettier is great; we have configured them and can run individual scripts whenever we make some changes to ensure everything is in the best order.

However, there are some drawbacks. Developers can forget to run all checks before committing to the repo, which can still bring problematic and inconsistent code to production.

Fortunately, there is a solution that can fix this problem: whenever we try to commit to the repository, we want to run all checks in an automated way.

Whenever we attempt to commit to the repository, the git pre-commit hook will run and execute the scripts that will do the checking. If all the checks pass, the changes will be committed to the repository; otherwise, we will have to fix the issues and try again.

To enable this flow, we will use `husky` and `lint-staged`:

`husky` is a tool that allows us to run git hooks. We want to run the pre-commit hook to run the checks before committing our changes.

`lint-staged` is a tool that allows us to run those checks only on files that are in the staging area of Git. This improves the speed of code checking since doing that on the entire code base might be too slow.

We already have these tools installed and configured, but if we didn’t, they could be installed using the following command:


```sh
npm install –-save-dev husky lint-staged
```
Then, we would need to enable Git hooks:


```sh
npx husky install
```
Then, we would need to create the pre-commit hook:


```sh
npx husky add .husky/pre-commit "npx lint-staged"
```

The Husky pre-commit hook will run lint-staged. Then, we would need to define what commands lint-staged should run inside the lint-staged.config.js file:


```js
module.exports = {
  '*.{ts,tsx}': [
    'npm run lint',
    "bash -c 'npm run types:check'",
    'npm run format:check',
  ],
};
```
If we try to commit code that contains any violations, it will fail and stop us from committing the changes.

⚠️ Run `husky` for the nested folder
- see the tip [here](https://stackoverflow.com/questions/53869155/how-to-run-husky-pre-commit-in-child-directory-only) or more detail at [here](https://scottsauber.com/2021/06/01/using-husky-git-hooks-and-lint-staged-with-nested-folders/)

**Use case**
my frontend folder: `/frontend/uz-app`

```json
# at /frontend/uz-app/package.json
{
  "scripts": {
      // other scripts omitted 
      "prepare": "(cd ../../ && husky install ./frontend/uz-app/.husky && touch ./frontend/uz-app/.husky/pre-commit)"
   }
}
```

At the `./husky/pre-commit` file, add the following content:
```sh
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"
cd ./frontend/uz-app && npx lint-staged 
```

Then add the permission
```sh
chmod +x .husky/pre-commit
```
