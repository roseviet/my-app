# How I setup the project

## Frontend

### NextJS

```sh
npx create-next-app@latest uz-app --typescript
```

There are a couple of things that are specific to Next.js. Let’s look at the following file and folder structure of a simple Next.js application:

```
- .next
- public
- src
  - pages
    - _app.tsx
    - index.tsx
- next.config.js
- package.json
```

Let’s analyze each file and folder one by one:

- `.next`: Contains production-ready files generated by running the build command of Next.js.

- `public`: Contains all static assets of the application.
`src/pages`: This is a special folder in Next.js where all pages defined here become available at corresponding routes. This is possible thanks to the filesystem-based routing system. The pages folder can also live in the root of the project, but it is nice to keep everything in the src folder.

- `src/pages/_app.tsx`: The _app.tsx file is a special file that exports a React component that wraps every page when rendered. By wrapping pages with this special component, we can add custom behavior for our application, such as adding any global configurations, providers, styles, layouts, and more to all the pages.

- `src/pages/index.tsx`: This is how we declare pages of the application. This shows how the root page is defined. 

- `next.config.js`: This is where we can extend the default functionalities such as Webpack configuration and other things in a simple way.

- `package.json`: Every Next.js application includes the following npm scripts:
    - `dev`: Starts a development server on localhost:3000
    - `build`: Builds the application for production
    - `start`: Starts the production build on localhost:3000

### TypeScript

Our project already has TypeScript configured. The TypeScript configuration is defined in the tsconfig.json file at the root of the project. It allows us to configure how strict we want it to be based on our needs:


```js
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "src"],
  "exclude": ["node_modules"]
}
```
We will not dive too deeply into every configuration property since most of the properties have been auto-generated. However, there is one thing that was also provided:

```js
"baseUrl": ".",
"paths": {
    "@/*": ["./src/*"]
}
```
This will tell the TypeScript compiler that anything imported via @/* will refer to the src folder.

Previously, we had to perform messy imports, like so:

```js
import { Component } from '../../../components/component'
```

Now, we can import components like so:


```js
import { Component } from '@/components/component'
```
No matter how many nested levels we have, we can always import with absolute paths, and we will not be required to change our import statement should we decide to move the consumer file somewhere else.

### ESLint
Linting is a process where linters analyze source code and detect any potential issues in the code base.

We will be using ESLint, which is the most popular linting tool for JavaScript. It can be configured with different plugins and rules to adapt the linter to our application’s needs.

The ESLint configuration is defined in the `.eslintrc.js` file at the root of the project. We can add different rules, extend them with different plugins, and override which files to apply the rules to so that they suit our application’s needs.

Sometimes, we don’t want to lint every folder and file, so we can tell ESLint to ignore folders and files by defining them in the `.eslintignore` file.

ESLint has great integration with editors and IDEs so that we can see any potential issues in the file while we are coding.

To run our linter, we have defined the linting script in `package.json`:


```json
"lint": "eslint --ext .ts,.tsx ./src",
```

By running npm run lint, we will lint every .ts and .tsx file in the src directory, and the linter will notify us about any potential issues.

### Prettier
Prettier is a great tool for formatting code. It enforces a consistent coding style across the entire code base. By utilizing the “format on save” feature in our IDE, we can automatically format the code based on the configuration provided in the .prettierrc file. It will also give us good feedback when something is wrong with the code. If it doesn’t auto-format, something is wrong with the code and it needs to be fixed.

Prettier comes with a default configuration out of the box. We can override this by creating the `.prettierrc` file and modifying the configuration.

Just as with ESLint, sometimes, there are files we do not want to auto-format. We can tell Prettier to ignore files and folders by adding them to the `.prettierignore` file.

To run Prettier, we have defined a couple of scripts in `package.json`:


```json
"prettier": "prettier \"**/*.+(json|ts|tsx)\"",
"format:check": "npm run prettier -- --check",
"format:fix": "npm run prettier -- --write",
```

As we can see, we can run `npm run format:check` to just check the formatting without trying to fix it. If we want to fix it, then we can run `npm run format:fix`, which will modify the files that need to be fixed.